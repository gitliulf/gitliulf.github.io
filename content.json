{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"gallery","text":"","link":"/gallery/index.html"}],"posts":[{"title":"flutter-install","text":"flutter 安装 设置环境变量windows在windows参考下面设置两个环境变量 PUB_HOSTED_URL https://pub.flutter-io.cn FLUTTER_STORAGE_BASE_URL https://storage.flutter-io.cn linux在linux下输入下面命令 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 下载并安装flutter后解压执行 flutter doctor 等待更新完成 flutter doctor","link":"/2019/05/13/Flutter-install/"},{"title":"android-build","text":"示例Android Build类 Android Build类 Build类提供了硬件厂商、编号、序列号、SDK版本等重要信息。类名：android.os.Build 常量名 说明 BOARD 底层板名称 BOOTLOADER Bootloader版本号 BRAND 品牌 CPU_ABI CPU指令集 CPU_ABI2 CPU第二指令集 DEVICE 工业设计名称 DISPLAY 显示给用户的构建ID字符串 FINGERPRINT 构建的唯一标识符 HARDWARE 硬件的名称 比如高通 HOST 主机 ID ID标签 MANUFACTURER 产品生产商 MODEL 手机型号 PRODUCT 产品名称 RADIO 无线电固件版本号 SERIAL 硬件序列号（如果可用） TAGS 逗号分隔标签描述构建，如”调试” TIME 出场时间 TYPE 构建类型 USER 构建用户名称 2.Build.VERSION类 Build.VERSION类提供了开发代号、内部版本、SDK版本等信息类名：android.os.Build.VEISION 常量名 说明 CODENAME 当前的开发代号 INCREMENTAL 使用的内部值表示这个构建底层的源代码控制 RELEASE 用户可见版本字符串 SDK_INT 用户可见的SDK版本的框架 3.Build.VERSION_CODES类 android.os.Build.VERSION_CODES枚举当前已知的SDK版本代号 常量名 说明 BASE 2008-10：第一个版本的android BASE_1_1 2009-02：第一个安卓更新，官方称为1.1 CUPCAKE 2009-05：android1.5 CUR_DEVELOPMENT 发展过程中构建的版本，但是未正式发布 DONUT 2009-09：android1.6 ECLAIR 2009-11：android2.0 ECLAIR_0_1 2009-12：android2.0.1 ECLAIR_MR1 2010-01：android2.1 FROYO 2010-06：android2.2 GINGERBREAD 2010-11：android2.3 GINGERBREAD_MR1 2011-02：android2.3.3 HONEYCOMB 2011-02：android3.0 HONEYCOMB_MR1 2011-05：android3.1 HONEYCOMB_MR2 2011-06：android3.2 ICE_CREAM_SANDWICH 2011-10：android4.0 ICE_CREAM_SANDWICH_MR1 2011-12android4.0.3 JELLY_BEAN 2012-06：android4.1 JELLY_BEAN_MR1 android4.2 JELLY_BEAN_MR2 android4.3 KITKAT android4.4 public void testDemo1(){ //Build类 System.out.println(&quot;Build:&quot;+Build.BOARD); System.out.println(&quot;Build:&quot;+Build.BOOTLOADER); System.out.println(&quot;Build:&quot;+Build.CPU_ABI); System.out.println(&quot;Build:&quot;+Build.CPU_ABI2); System.out.println(&quot;Build:&quot;+Build.DEVICE); System.out.println(&quot;Build:&quot;+Build.DISPLAY); System.out.println(&quot;Build:&quot;+Build.FINGERPRINT); System.out.println(&quot;Build:&quot;+Build.HARDWARE); System.out.println(&quot;Build:&quot;+Build.HOST); System.out.println(&quot;Build:&quot;+Build.ID); System.out.println(&quot;Build:&quot;+Build.MANUFACTURER); System.out.println(&quot;Build:&quot;+Build.MODEL); System.out.println(&quot;Build:&quot;+Build.PRODUCT); System.out.println(&quot;Build:&quot;+Build.RADIO); System.out.println(&quot;Build:&quot;+Build.SERIAL); System.out.println(&quot;Build:&quot;+Build.TAGS); System.out.println(&quot;Build:&quot;+Build.TIME); System.out.println(&quot;Build:&quot;+Build.TYPE); System.out.println(&quot;Build:&quot;+Build.USER); System.out.println(&quot;Build:&quot;+Build.BOARD); //Build.VERSION类 System.out.println(&quot;Build.VERSION:&quot;+Build.VERSION.CODENAME); System.out.println(&quot;Build.VERSION:&quot;+Build.VERSION.INCREMENTAL); System.out.println(&quot;Build.VERSION:&quot;+Build.VERSION.RELEASE); System.out.println(&quot;Build.VERSION:&quot;+Build.VERSION.SDK_INT); //Build.VERSION_CODES类 System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.BASE); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.BASE_1_1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.CUPCAKE); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.CUR_DEVELOPMENT); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.ECLAIR); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.ECLAIR_0_1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.ECLAIR_MR1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.FROYO); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.GINGERBREAD); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.GINGERBREAD_MR1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.HONEYCOMB); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.HONEYCOMB_MR1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.HONEYCOMB_MR2); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.ICE_CREAM_SANDWICH); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.JELLY_BEAN); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.JELLY_BEAN_MR1); System.out.println(&quot;Build.VERSION_CODES:&quot;+Build.VERSION_CODES.JELLY_BEAN_MR2); }","link":"/2019/04/25/android-build/"},{"title":"app-reset-design","text":"定义apiResultFull api 根据resetfull API 规范定义一个自己的 api规范定义格式如下 /app/userid/resnameGET 查询POST 新增PUT 修改DELETE 删除 所有请求使用http中请求类型表示其目的url只定义资源的路径包含一下几个动作类型资源服务器提供登录验证资源服务器提供版本支持和不同格式的请求第一个版本只提供json的格式请求","link":"/2019/04/25/app-rest-desig/"},{"title":"cmmi-compnny","text":"国内做cmmi认证的公司 北京 麦哲思科技(北京)有限公司 北京翰通融达管理咨询有限公司 北京国信普道科技有限公司 中质信安(北京)信息科技有限公司 北京昊诚亚旭科技有限公司 深圳 深圳致卓信息技术有限公司 武汉 武汉惟特信息技术有限公司 上海 上海科维安信息技术顾问有限公司 上海静脉信息科技有限公司 广州 广州赛宝认证中心服务有限公司 福州 百诺企管","link":"/2019/05/14/cmmi-compnny/"},{"title":"cmmi简介","text":"CMMI 简介 CMMI是英文Capability Maturity Model Integration的缩写。CMMI认证简称软件能力成熟度集成模型，是鉴定企业在开发流程化和质量管理上的国际通行标准，全球软件生产标准大都以此为基点，并都努力争取成为CMMI认证队伍中的一分子。对一个软件企业来说，达到CMMI2就基本上进入了规模开发，基本具备了一个现代化软件企业的基本架构和方法，具备了承接外包项目的能力。CMMI3评估则需要对大软件集成的把握，包括整体架构的整合。一般来说，通过CMMI认证的级别越高，其越容易获得用户的信任，在国内、国际市场上的竞争力也就越强。CMMI一共分为五个等级： 第一级： 初始级软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。 第二级：可管理级建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 第三级： 已定义级已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准来开发和维护软件，软件产品的生产在整个软件过程是可见的。 第四级：量化管理级分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 第五级：优化管理级过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。","link":"/2019/04/22/cmmi/"},{"title":"huawei-compatible","text":"华为iot Agent lite 认证 1. 设备接入和删除1.1 AgentLite_认证_接入和删除_001 测试方法：在平台上注册设备后，进行绑定操作，在平台上从离线变为在线状态 测试数据： 应用平台（APPServer）截图 测试步骤2的截图 平台截图 预期结果3的截图，离线在线状态图各一张，deviceid一致 1.2 AgentLite_认证_接入和删除_002 测试方法：将已在线的设备删除 测试数据： 应用平台（APPServer）截图 测试步骤2的截图 平台截图 预期结果2，3的截图，平台上用deviceid查询此设备时结果为空 1.3 AgentLite_认证_接入和删除_003测试方法：设备在线后，下电离线后再删除 测试数据： 应用平台（APPServer）截图 测试步骤2的截图 平台截图 预期结果2，3的截图，平台上用deviceid查询此设备时结果为空 # 2 设备数据上报2.1 AgentLite_认证_数据上报_001测试方法：设备电池供电，上报电量 测试数据： 应用平台（APPServer）截图 预期结果4的截图 平台截图 预期结果4的截图 2.2 AgentLite_认证_数据上报_002测试方法： 电池供电，低电量时，上报低电量告警 测试数据： 应用平台（APPServer）截图 预期结果4的截图 平台截图 预期结果4的截图 2.3 AgentLite_认证_数据上报_003（可选）测试方法： 绑定设备成功后，电量也上报到平台，非手动触发上报 测试数据： 应用平台（APPServer）截图 预期结果4的截图 平台截图 预期结果4的截图 2.4 AgentLite_认证_数据上报_004测试方法： 设备触发基本数据上报，比如温度，湿度等。 测试数据： 应用平台（APPServer）截图 预期截图结果2的 平台截图 预期结果2的截图 2.5 AgentLite_认证_数据上报_005测试方法： 设备离线状态上报 测试数据： 应用平台（APPServer）截图 预期结果2的截图 平台截图 预期结果2的截图 3 初始化（可**选）**3.1 AgentLit_认证_初始化_001测试方法：初始化设备到出厂设置 测试数据： 应用平台（APPServer）截图 预期结果截图 平台截图 预期结果截图 4 可靠性4.1 AgentLite_认证_可靠性_001测试方法：电池供电，插拔传感器电池，10次 测试数据： 应用平台（APPServer）截图 预期结果4截图，每次上线下线，上报数据的截图 平台截图 预期结果4截图，每次上线下线，上报数据的截图 5 稳定性5.1 AgentLite_认证_稳定性_001（可选）测试方法：传感器信号干扰测试 测试数据： 应用平台（APPServer）截图 预期结果1截图 平台截图 预期结果1截图 5.2 AgentLite_认证_稳定性_002测试方法：设备运行72小时，不断电，稳定上报数据 测试数据： 应用平台（APPServer）截图 预期结果2截图 平台截图 预期结果2截图 6 固件升级与回退（可**选）**6.1 AgentLite_认证_升级_001测试方法：在平台上传升级包，创建升级任务，下发升级任务给设备。 测试数据： 平台截图 预期结果6，7，8，9截图 6.2 AgentLite_认证_回退_002测试方法：在平台创建回退任务，下发回退任务给设备。 测试数据： 平台截图 预期结果6，7，8，9截图","link":"/2019/05/14/huawei-compatible/"},{"title":"user-linux","text":"linux 下用户管理 如何添加或删除ubuntu用户和组在创建用户时，需要为新建用户指定一用户组，如果不指定其用户所属的工作组，自动会生成一个与用户名同名的工作组。创建用户user1的时候指定其所属工作组users，例：useradd –g users user1 一、创建用户： 使用命令 useradd例：useradd user1——创建用户user1useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 用户的缺省UID从500向后顺序增加，500以下作为系统保留账号，可以指定UID， 例：useradd –u 600 user3 使用 passwd 命令为新建用户设置密码例：passwd user1注意：没有设置密码的用户不能使用。 命令 usermod 修改用户账户例：将用户 user1的登录名改为 u1，usermod –l u1 user1例：将用户 user1 加入到 users组中，usermod –g users user1例：将用户 user1 目录改为/users/us1 使用命令 userdel 删除用户账户例：删除用户user2userdel user2例：删除用户 user3，同时删除他的工作目录userdel –r user3 查看用户信息id命令查看一个用户的UID和GID, 例：查看user4的idid user4finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息例：finger user4 二、用户组： 命令 groupadd创建用户组groupadd –g 888 users创建一个组users，其GID为888 命令 gpasswd为组添加用户只有root和组管理员能够改变组的成员：例：把 user1加入users组gpasswd –a user1 users例：把 user1退出users组gpasswd –d user1 users 命令groupmod修改组groupmod –n user users 修改组名user为users groupdel删除组groupdel users 删除组users","link":"/2019/04/22/linux-user/"},{"title":"Hello","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2019/04/22/hexo/"},{"title":"node-restify","text":"A Node.js web service framework optimized for building semantically correct RESTful web services ready for production use at scale. restify optimizes for introspection and performance, and is used in some of the largest Node.js deployments on Earth.","link":"/2019/04/25/node-restify/"},{"title":"npm 使用国内源","text":"切换npm使用的源地址 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源。不安装 cnpm 只用淘宝镜像，设置 npm 的镜像：$ npm config set registry https://registry.npm.taobao.org/执行下面的命令，确认是否切换成功。$ npm config get registry","link":"/2019/04/30/npm-to-ali-source/"},{"title":"ubuntu-apt","text":"debian apt常见用法 apt 命令在Ubuntu下，apt-get近乎是最常用的shell命令之一了，因为他是Ubuntu通过deb安装软件的常用工具命令。 下面列举常用的 apt命令 apt-cache search package 搜索软件包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package –reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package 删除包 sudo apt-get remove package –purge 删除包，包括配置文件等 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 apt-cache depends package 了解使用该包依赖那些包 apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖","link":"/2019/05/16/ubuntu-apt/"},{"title":"http-method-definitions","text":"介绍http中method的定义 Method DefinitionsThe set of common methods for HTTP/1.1 is defined below. Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers. The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests. 9.1 Safe and Idempotent Methods9.1.1 Safe MethodsImplementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others. In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered “safe”. This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested. Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them. 9.1.2 Idempotent MethodsMethods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent. However, it is possible that a sequence of several requests is non- idempotent, even if all of the methods executed in that sequence are idempotent. (A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence. A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources). 9.2 OPTIONSThe OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval. Responses to this method are not cacheable. If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field. Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. A server that does not support such an extension MAY discard the request body. If the Request-URI is an asterisk (““), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. Since a server’s communication options typically depend on the resource, the ““ request is only useful as a “ping” or “no-op” type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof). If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource. A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification. The response body, if any, SHOULD also include information about the communication options. The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP. Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of “0”. The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. If the Max-Forwards field-value is zero (“0”), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options. If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field. 9.3 GETThe GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process. The semantics of the GET method change to a “conditional GET” if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client. The semantics of the GET method change to a “partial GET” if the request message includes a Range header field. A partial GET requests that only part of the entity be transferred, as described in section 14.35. The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client. The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13. See section 15.1.3 for security considerations when used for forms. 9.4 HEADThe HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification. The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale. 9.5 POSTThe POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. POST is designed to allow a uniform method to cover the following functions: - Annotation of existing resources; - Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles; - Providing a block of data, such as the result of submitting a form, to a data-handling process; - Extending a database through an append operation. The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database. The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result. If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30). Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource. POST requests MUST obey the message transmission requirements set out in section 8.2. See section 15.1.3 for security considerations. 9.6 PUTThe PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request – the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request. A single resource MAY be identified by many different URIs. For example, an article might have a URI for identifying “the current version” which is separate from the URI identifying each particular version. In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server. HTTP/1.1 does not define how a PUT method affects the state of an origin server. PUT requests MUST obey the message transmission requirements set out in section 8.2. Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT. 9.7 DELETEThe DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location. A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. 9.8 TRACEThe TRACE method is used to invoke a remote, application-layer loop- back of the request message. The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). A TRACE request MUST NOT include an entity. TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop. If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of “message/http”. Responses to this method MUST NOT be cached. 9.9 CONNECTThis specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling [44]).","link":"/2019/04/25/http-method-definitions/"},{"title":"crontab-定时使用","text":"linux 定时器的使用 crontab 定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 1. 命令格式 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 2. 命令参数 -u user：用来设定某个用户的crontab服务； file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 3. crontab的文件格式分 时 日 月 星期 要运行的命令 第1列分钟0～59 第2列小时0～23（0表示子夜） 第3列日1～31 第4列月1～12 第5列星期0～7（0和7表示星期天） 第6列要运行的命令 4. 常用方法创建一个新的crontab文件向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$HOME目录下的. profile文件，在其中加入这样一行: EDITOR=vi; export EDITOR 然后保存并退出。不妨创建一个名为 cron的文件，其中是用户名，例如， davecron。在该文件中加入如下的内容。 # (put your own initials here)echo the date to the console every # 15minutes between 6pm and 6am 0,15,30,45 18-06 * * * /bin/echo 'date' &gt; /dev/console 保存并退出。注意前面5个域用空格分隔。 在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数: $ crontab davecron 现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。 列出crontab文件使用-l参数列出crontab文件: $ crontab -l 0,15,30,45 18-06 * * * /bin/echo `date` &gt; dev/tty1 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l &gt; $HOME/mycron 这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。 编辑crontab文件如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件: $ crontab -e 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条： # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month 30 3 1,7,14,21,26 * * /bin/find -name 'core' -exec rm {} \\; 保存并退出。 注解 最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。 删除crontab文件$crontab -r 5. 使用实例实例1：每1分钟执行一次myCommand* * * * * myCommand 实例2：每小时的第3和第15分钟执行3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb0 23-7 * * * /etc/init.d/smb restart 6. 使用注意事项注意环境变量问题有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 脚本中涉及文件路径时写全局路径； 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如: cat start_cbp.sh !/bin/sh source /etc/profile export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf /usr/local/jboss-4.0.5/bin/run.sh -c mev &amp; 当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如: 0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 注意清理系统用户的邮件日志每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出: 0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1 “/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 系统级任务调度与用户级任务调度系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 其他注意事项新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。 当crontab失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。 更新系统时间时区后需要重启cron,在ubuntu中服务名为cron: $service cron restart ubuntu下启动、停止与重启cron: $sudo /etc/init.d/cron start $sudo /etc/init.d/cron stop $sudo /etc/init.d/cron restart","link":"/2019/04/22/linux-crontab/"},{"title":"cmmi3","text":"cmmi3 认证介绍 CMMI3证书是什么/CMMI认证CMMI认证是由美国软件工程学会(software engineering institue,简称SEI)制定的一套专门针对软件产品的质量管理和质量保证标准. CMMI 的全称为：Capability Maturity Model Integration，即能力成熟度模型集成。近年来，很多软件企业纷纷实施CMMI管理模式，不少企业如：东软，托普，华为等企业通过了三级或四级评估。这一方面反映了我国企业在进入WTO后的危机意识，以及与世界接轨的迫切愿望。另一方面则反映出我国软件企业在改进管理方法上所作的努力。但是CMMI到底能够为我们做什么呢？实际上这个问题对不同的人有不同的答案。对采购部门的人员来说，掌握了CMMI技术可以有目的地考察项目实施人员或公司的实施能力，从而保证所采购的项目能够顺利完成。对于项目经理来说，掌握CMMI技术能够提高自己的项目管理能力，从而能够使项目高质量，低成本，按期限地完成。对于企业老总来说，CMMI技术不仅能够提升企业的管理水平，还能够引入科学的管理理念，提升企业的整体管理水平。 CMMI3的证书的周期和费用：/CMMI认证首先是费用问题，因为CMMI不像国内一些认证，花点钱，走个流程就可以首先要给认证公司一笔前期的培训和辅导费用，一般来说在15W左右。然后最后的评估阶段，大概也需要15W左右，这个主要是付给主任评估师的费用，如果是老外还需要支付翻译的费用，很贵，老外一般一天至少1万多，最后初评和最终评估加起来估计要10来天。CMMI的认证过程，一般需要前期培训、标准过程导入、几个项目实施标准过程、最后进行评估等几个阶段，正常点的话，半年到1年是至少需要的，这里我们来谈谈哪些过程可以缩短甚至跳过。 前期培训，这个是可以大幅度缩短的，让辅导老师过来花个2、3天讲课，突击培训一下，让大家了解CMMI的体系。 标准化导入，这个也是可以缩短的，让认证公司提供一套模板，根据公司实际情况，安排人员突击完成，然后辅导老师提出意见，然后再修改，再审核，来回2、3次，算半个月时间好了。 几个项目实施标准过程，这个就要看公司人力资源配合度了，首先让认证公司，提供一个项目完整的所有的材料模板，公司组织人员根据公司研发项目，安排4个（最少的要求了）对照模板进行编制（这里为了省时间，全部是编造，所以时间点一定要注意，省的后面麻烦），如果人力资源配备充足，那么4个项目，我想半个多月时间可以完成（4个项目全部弄完，文档起码有6000多个，工作量很大） 最后的评估阶段，要安排主任评估师的日程，因为最后需要一个初评和最终评估，按照要求，初评3天左右时间，中间隔1个星期给你进行修改，最终评估一般要7天，所以保守估计，评估阶段，也是需要半个多月。 最后关键的来了，评估完成后，主任评估师，需要再SIE网站上，去整个评估过程，公司信息等进行注册，然后提交评估材料给SEI进行审核，等待SEI的最终评审，通过后，会在SEI网站上进行公布。这里要注意了，SEI本身是不给你发证的，这个证书是由认证公司给你发的，只是上面会写明你的评估通过时间和等级，以及主任评估师等信息，到底真实性如何，SEI的网站信息为准，所以，中间这段等待的时间，大概要1个月，就要算进去，只有SEI网站信息公布了，认证公司才可以给你发证。 通过CMMI3级评估之后还需升级 /CMMI认证因为美国SEI对于CMMI各级别（2-5）以及模型的评估是有时限要求的（3年），而且伴随着CMMI以产品化方式发布地进行（主要是模型与评估方法的升级），所以从企业CMMI证书与ATM人员资格两方面都需要进行CMMI升级或CMMI复评。CMMI升级作为企业研发过程管理能力提升的一项里程碑活动，其作为从CMMI3级的组织级研发过程管理状态程度提升到以cmmi4级量化数据管理（或CMMI5级持续化自主过程改进）的状态程度，是企业“内功”沉淀的优化方式与途径。 公司下面的某一个部门实施CMMI认证：/CMMI认证我们可不可以只在公司下面的某一个部门实施CMMI，以便减少实施的难度？A：可以，因为CMMI 中反复使用的是“组织”一词，它既可以代表一家完整的公司，也可以代表一家公司下面的一个或多个部门。因此，即使在评估CMMI 5 级的时候，也可以只对某家公司的某一个部门进行。CMMI 2级是面向项目级别的，实施的时候这方面灵活性更大。不过在主任评估师向SEI 提交评估结果时会明确写明评估的时候是在企业的什么范围内进行的（多少个部门纳入了评估的范围，大约参与的软件开发人员和管理人员的数量等）。现在很多企业向媒体宣传的时候，有意无意的掩盖了这一点，只是泛泛地说：XXX 公司已经达到了CMMI 2 级的要求，久而久之造成了很多错误的认识。不过，如果企业希望通过过 程改进真正获益的话，最好还是能够在整个企业中所有与软件活动有关的的部门都实施过程改进。虽然2 级是面向项目级别的，但我们非常欢迎和支持在整个公司的范围内实施CMMI 2级，无论这些部门的软件项目是开发类的、实施或维护类的，也不论这些项目是面向客户的工程类的、还是面向市场的产品类的。这样，公司积累大量不同类型项目的宝贵经验，在将来向3 级迈进的时候，充分利用这些经验可以把3 级的实施落在实处，得到更加广泛的认同。我个人认为，如果一家公司希望能够成为CMMI 3 级的公司的话，如果在2 级的阶段投入比较多，实施的效果比较好，那么3 级的实施难度会下降很多；反之，如果2 级阶段投入较少，实施范围小、效果不是很好的话，3 级的实施难度会增加；因此可以说，一个公司在从1 级到3 级这个过程中所投入的资源（人员、时间、资金等）总数基本上是一个固定值。既然如此，为什么不早一点把工作做到实处，早一点获得成效呢？ 不同国籍的CMMI主任评估师资质：/CMMI认证A：据不完全统计，目前在全球范围内SEI 授权的主任评估师有300 多位，不过不同的CMMI主任评估师在资质上面并不是全都相同。这要从如何成为主任评估师说起：如果要成为主任评估师，除了自身要有相当丰富的软件工程、项目管理等相关知识背景外，还要参加大量的SEI 组织的CMMI 相关知识的官方培训。在正式成为主任评估师以前，必须亲自主持一次正式评估工作，由已经得到授权资格的主任评估师进行考察，如果这次评估工作经过考察没有出现严重的问题和错误，SEI 将颁发主任评估师的授权认证。这样的证书在2 年内是有效的，有效期内主任评估师可以主持正式评估，其结果SEI 认可，也可以监控其他主任评估师候选人主持正式评估的工作。本来这样的做法可以使成为主任评估师的“门槛”很高，但是还是存在一定的漏洞：如果一个人有个好朋友是主任评估师，他也想成为主任评估师，而他的朋友又不能很好的坚守原则，这样就很容易“混入”主任评估师的队伍。另外，目前很多主任评估师在给客户作评估之前，往往还提供一些相关的咨询服务，这种“既当教练又当裁判”的情况也难免会使一些主任评估师在作评估的时候放松尺度，使得进行过程改进的企业所有的过程改进工作变成了“花钱买认证”，而没有真正从中获益。基于上述情况，目前国内一些比较有实力的咨询公司为了保证自己的服务质量，也为了能使国内的软件企业在进行基于CMMI 的过程改进的时候达到真正的效果，在主任评估师的选择上坚持高标准和严要求。他们去请在欧美国家知名度很高、信誉很好的主任评估师来国内主持正式评估工作。这些主任评估师中很多都是SEI 首批授权的主任评估师，有些人甚至就是参与制定CMMI 的人员。这些主任评估师经验丰富，对于CMMI 的理解非常深刻，而且坚持原则，虽然这对国内的企业来说实施难度也增加了一些，但能够在这样的要求下达到CMMI2级以上的评价才是货真价实的。还有一点，目前很多国内的软件企业也希望和印度的软件企业一样，通过实施CMMI 提高自身过程的能力成熟度，以便在海外市场上获得更多的外包订单。这个时候不同的主任评估师也会产生不同的效果。比如，当一家国内的软件企业在和一家美国的企业洽谈外包业务时，告知对方我们已经于某个时间达到了CMMI2级以上的成熟度，对方很可能要了解是由哪位主任评估师来做的评估，如果对方在美国知名度很高，对方可能对这家企业“刮目相看”，后面的洽谈可能就会容易很多。这就像在日常生活中，同样是硕士学位，但知名度高的导师带出来了学生更容易被人接受是一样的道理。 咨询公司对实施CMMI 有什么帮助 /CMMI认证A：目前有不少的软件企业希望通过自身的努力进行过程改进，然后进行正式评估，这是很常见的一种做法。不过，如果希望在实施 的过程中困难少一点儿，时间短一点儿的话，最好还是与经验丰富的咨询公司合作。主要的原因在于：★ CMMI 作为一个模型，具有高度的抽象性。因此CMMI 中并没有提出一家软件组织必须如何去做才算是达到了要求，它提出的只是 “做什么”。举个日常生活中的例子来说，CMMI 提出的要求就好像一家公司要求地面要保持清洁，至于是用扫把扫还是用吸尘器吸 并不重要。同样对于CMMI 中的要求，可以有很多种不同的实践来满足。可是，到底什么实践在自己的企业中实施起来既比较有效， 还能达到CMMI的要求，对于刚开始实施CMMI 的软件企业来说，这种判断和选择是很难把握的。而经验丰富的咨询公司结合了大量国 内软件公司的实践、业内的最佳实践以及主任评估师推荐的实践，帮助企业达到CMMI 的要求，而且还比较简单易行，实施效果已经 经过了很多次的证明，自然能够达到“事半功倍”的效果。★ 咨询公司对于企业在实施过程中出现的问题经验丰富，可以有效的减少做错事情的可能性。比如高层经理对过程改进不够重视或 者有一些误解，特别是资源方面的问题，咨询公司都可以及时发现，并协助参与实施的人员减少随之带来的负面影响。★ 如果有些企业希望在一个既定的时间目标下达到某个成熟度级别，咨询公司可以帮助实施企业监控进度，对于发现进度落后的情 况，根据咨询师的经验也可以及时发现，及时采取纠正措施跟上进度。★ 如果企业自己实施CMMI，还需要自己联系主任评估师，这样在费用上可能会开销很大，咨询公司如果提供评估服务，他们可以根 据企业的需求（包括资质和成本等多方面）帮助企业联系到合适的主任评估师，减少了企业自己联系的麻烦和额外的成本。 CMMI评估的预备工作都有哪些 /CMMI认证评估实践证明：在进行CMMI评估之前，制定一个正确的评估计划并将其文档化，确保有一个富有经验的、受过培训且具有适当资格的小组能被用来评估，为执行评估过程做准备，是十分必要的。 我们所说的文档化评估计划的结果，包括：要求，协定，估价，风险，剪裁方法，以及与评估相关的实际考虑（例如：日程安排，后勤，组织的背景信息）。此外，还应当获取并记录发起方对于评估计划的正式批准。在制定评估计划之前，应对评估输入中反映出来的协议文档化，该协议将有助于评估目标和关键评估计划参数的共同理解。在对驱动计划过程的关键参数达成共同理解的基础上，评估发起方和scampi主任评估师应就评估计划达成一致；发起者和评估小组领导应就已计划的评估中技术和非技术细节达成一致。这个计划在执行其他的计划和准备阶段活动中需要进一步细化。而通过评估小组的准备工作，将产生一支富有经验的、受过培训的且定位准确的小组准备执行评估任务。该小组的成员都应当获得了完成他们各自的任务所必备的知识，或者他们之前所拥有的知识被证实足以完成相关任务。评估小组领导者已经给每一个人提供了为完成他们各自的任务所需的对技能进行实践的机会，或者证实这些技能在过去已经得到了示范。小组成员相互了解，同时开始计划他们如何协调一致的工作。还应该做到：准备好的小组是为评估目标而服务的，小组的成员已提供培训且培训结果被记录，在必要的时候，对他们所做的因知识或技能不足的补救工作已经完成。我们认为，无论评估小组领导者是从头培训一支全新的评估小组，还是通过从富有经验的小组成员中选择来组建一个小组，确保他们与评估小组领导者能组成一个成功的集体是其责任。为便于说明我们的观点，下面按照实际操作的顺序列出了与CMMI评估相关的预备工作。 一.进行恰当的剪裁由于SCAMPI是设计用于满足大范围的评估应用，所以剪裁是一个值得仔细的全程关注的活动。SCAMPI的剪裁方法包括：对所要求实践中的机会进行选择，设置参数和限制评估过程中可以改变的参数，以及包含可选实践。在剪裁过程中，需要注意： 在每一个活动的必需实践中评估和选择裁剪部分； 当预期变更发生时，在可接受的界限内评估和设置参数； 评估和选择适当的任意实践； 确保裁剪的结果是首尾一致的，并且根据评估目标和约束是恰当的； 生成裁剪结果文档。 MDD的结构阐明了SCAMPI具有的特征，要么被看作ARC需求的一个直接派生，要么被看作SCAMPI需求。参数和限制区在这些方法需求内详细说明了可承认的变更。裁剪向导和执行向导被用来帮助调整方法以适应评估发起者目标和评估约束。裁剪方法和执行部分必须在某种程度上保证没有违背SCAMPI的必需实践。 二.对评估所需要的资源进行标识本活动是与执行评估所需资源的鉴定和评估相关的。评估所需的资源包括人员、设备、工具以及有权使用的信息。具体的行为有： 确定评估组成员； 确定评估参与者； 确定设备和工具； 确定所需的其他评估资源； 文档化在评估计划中的资源决议。 此外，在鉴定过程中所需资源的详细程度必须足够支持评估计划的实施。例如，确定评估组的领导人，参与接见的候选人姓名和拥有评估组成员资格者的姓名，这些人在组织上和项目上的从属关系，被评估组使用的地点、座位容量和房屋外形，所需要的特殊设备(如：高摄投影仪、膝上形电脑放映机、视频会议)。 三.确定评估所需的费用以及日程安排本活动是在评估计划中包含并列出最高费用的明细表以及进度表。具体的行为包括： 估计关键事件持续时间，并以此作为制订全面进度表的基础； 估计参与评估的人员所需的努力； 恰当地估计使用工具和设备的相关费用； 适当地估计伴随事件的费用(如：出差、住宿、吃饭)； 在评估计划中文档化详细的估计进度； 在评估计划中文档化详细的估计费用。 评估成果的取得不仅取决于评估组，还取决于整个组织单位内的预期参与者(如：被访问者、管理设备的相应人员、简报的出席者、支持者)。因此，我们必须对评估过程的每一天进行计划。 四.对后勤计划进行管理本活动强调评估过程中的每一个相应部分的后勤保障细节应该在协商后取得一致并文档化。评估组领导要取得组织单位协调者的支持，对文档中的计划任务进行管理并与后勤保障计划进行协调。检查制度和行动条款跟踪机制是用于管理这些任务非常有用的组织结构。具体的行为包括： 文档化后勤保障计划，增强其可靠性； 保持与供应状况的沟通渠道； 指定跟踪后勤保障问题的职责。 我们知道，有效的计划取决于对评估中可能发生的后勤保障问题变更的预见性。这些有时被忽略的问题包括： 确定在评估中所住的旅馆； 提供工作站支持； 对吃饭进行管理； 在某个时刻设备的相互影响； 会议的安全/分级需求； 为得到的有限设备的护送提供证章或者管理。 五.对风险进行管理并将其文档化由于任何项目都取决于事件、人物和其他资源，风险管理是其成功的一个重要因素。评估组领导有责任在发起者和评估组成员之间沟通风险和相关的减缓风险计划，并生成文档。具体的行为包括： 确定评估风险； 对评估过程中的关键风险提出减缓计划并在必要时执行这些计划； 记录风险评估发起者和其他风险产生者在风险评估中的地位。 通过对活动的管理而确定的风险因素及减缓计划是评估计划的必需元素。在评估计划中大部分领导评估者应当拥有风险管理的头衔，专注于风险管理活动的努力水平是评估组领导必需调整以适应即将到来的情况所需要的。 六.获得评估计划的许可评估计划应获取正式发起者的许诺。由于这个协议的正式性是如此至关重要，评估计划需要在评估发起者和评估组领导之间签订一个合同。具体的行为包括： 文档化评估计划； 和评估发起者一起重新审查评估计划，并获得发起者的正式批准； 为相关的风险产生者提供评估计划以便重新审查。 评估计划的必需内容至少包括如下几项： 评估输入； 在风险管理中所执行的活动； 风险管理所需的资源； 用于完成评估所需的费用和进度估计； 评估的后勤保障； 与实施评估相关的风险因素和减缓计划； 如果评估发起者要求满足ISO/IEC 15504需求时的检验标准。 此外，我们必须为评估组领导和发起者提供一个签名区，以指出他们在评估计划中各自所承担的义务。当然，如果评估计划还有其他次要的补充资料，并无须重新签名，除非一个或更多的评估输入元素被更改。至少，评估组成员应考虑过相关的风险产生者，并应得到一个获得批准的评估计划的复件。 七.选择评估小组领导评估发起者有责任选择一个评估小组的领导者，这个人应该拥有足够的经验、知识、技术来负责和领导评估活动。一个评估小组领导者必须是由SEI评估程序授权的SCAMPI主任评估师，同时必须以良好的状态作为评估过程的一名成员。在SEI网站上有SEI评估程序的详细描述。评估小组领导者有责任保证评估是根据SCAMPI的要求进行的，所做的裁剪必须满足在该方法定义下的允许范围内的评估目标和约束。具体的行为包括： 选择一个经SCAMPI授权的主任评估师担任评估小组领导者； 检验评估小组领导者的资格(经验、知识和技术)。 评估小组领导者必须是一名状态良好的经SEI授权的SCAMPI主任评估师。这一要求必须通过网络或与SEI CMMI办事机构直接联系得到确认。在任何已进行的评估中只能有唯一一名正式的评估小组领导者。他是唯一能判断给评估小组成员委派何种重要任务的人，但是他不能赋予其成员有关评估活动是否成功完成的领导职责和最终职责。特定评估小组中多重领导评估者对该评估小组的领导具有很重要的作用。但是，唯一指定的评估小组领导者必须履行其领导和管理评估过程的职责。 八.选择评估小组成员本活动包括识别有用的职员、评定其资格和从中挑选人员作为评估小组成员。它可以发生在评估发起者作出管理评估活动的许诺之后，并能为评估计划保证提供输入。具体的行为包括： 保证评估小组成员满足个人的最低标准； 保证评估小组作为一个整体满足的最低标准； 文档化在评估输入中小组成员的职责和资格。 SCAMPI评估可接受的评估小组最小规模是4个成员(包括小组领导者)。推荐的最大规模是9个成员。所有小组成员之前必须完成获得SEI推荐的并由SEI认可的权威授课者所教授的CMMI课程。小组成员必须接受有关评估方法的培训。关于工程领域的经验，评估小组(作为一个整体)平均至少要有6年以上的经验，且小组总的经验要不少于25年，这些规定都隐藏在评估活动中。关于管理经验，评估小组(作为一个整体)总的经验不能少于10年，且至少有1名成员拥有6年以上的管理经验。总的来说，评估小组应该在评估组织内部所使用的生命周期里具有有代表性的经验。在任何特定的生命周期阶段，评估小组至少应有两名成员具有从事这方面工作的经验。此外，必须保证，小组成员不应该成为任何特定项目的管理者或者成为任何预定被访问者的直接管理链中的一个。 九.准备评估小组评估小组领导者有责任确保评估小组成员为执行计划的评估活动完成充分的准备。这包括熟悉在评估过程中将使用的参考模型、SCAMPI、评估计划、组织数据和特征、工具和技术以及为评估任务分配任务和职责。小组建立练习通常被用来实践简单的技能和在理解小组目标及如何取得满意上达成一致。所有的小组成员被要求遵守严格规则以保证机密性、保护所有者或敏感数据以及项目参与者未知的信息。私下陈述通常被用来达成这些谅解。具体的行为包括： 保证评估小组成员已接受参考模型培训； 为评估小组成员提供评估方法培训或确保他们已掌握此方法； 为评估小组和小组规范的建立提供服务； 为评估小组成员提供关于评估目标、计划和他们自身分配的职责和任务的定位。 模型培训必须利用CMMI课程的权威标准来提供，并由CMMI办事机构权威认证的授课者讲授。方法培训可能通过下面两种方法之一进行： 针对即将到来的评估作明确性的方法培训； 对大量的目前并没有从事任何评估工作的潜在的小组成员进行方法培训。 对一个完全重新组建的小组进行方法培训至少持续两天，且必须强调那些小组成员在评估过程很可能遇到的情况。本培训在SCAMPI的应用中没有必要包含所有的变量。针对潜在的将来的小组成员所进行的团体式方法培训必须包含方法上剪裁部分的所有内容和允许的变更以应付一系列在将来的评估中他们很可能会遇到的情况。SEI评估程序为那些目前不是评估小组成员的人们所得到的培训指定了额外的要求。那些在以前的评估小组中作为成员已接受过培训的小组成员，如果并没有进行目前的方法培训，那么他们并不自动地具有参加当前评估的资格。在这样的案例中，评估小组领导者要求了解以前的培训的本质和为即将到来的评估开展的培训足够多的内容。这需要对以前的评估和计划的评估进行比较。例如，假如小组成员使用连续表示法参与了一个仅集中在软件工程领域的评估，而计划的评估是使用阶段表示法集中在SE/SW/IPPD领域，那么该小组成员需要许多重要的新概念来覆盖。作为一个整体，评估小组至少产生一个结果来说明如何为即将到来的评估展开工作，建立小组规范和操作决议的目的。 小结上面，我们按照评估过程中实际操作的顺序列出了与CMMI评估相关的预备工作。此外，在对CMMI评估进行的预备工作的过程中，我们还应当对模型剪裁的原则有所了解： 在某些应用中，计划模板和例行的程序能够根据评估的需要进行调整，这和当地的过程所有权一样，有助于交流； 一个结构化的计划工艺组有利于只有有限的评估经验的组织，这样一个工艺就像缓和策略样，对于发现风险是一个很有价值的机会； 案例研究材料提供了各种各样的选择来扩充小组培训内容以增强那些更需要培训的重点； 富有经验的评估小组领导者在没有案例分析的情况下，同样可以管理和模拟评估行为； 在小组所有已获得培训成员的集合中，对小组的建立工作进行管理以确保其团队凝聚力是十分重要的，因此，很多的小组建立练习是可以利用的，小组的规模、技能、组成部分都是本方法的裁剪内容； 所采用工具可以包括评估计划模板，样例，和计划模板中嵌入式的程序上的帮助，此外，为了估计评估约束的影响，估算工作表和方法也是很有用处的。 总之，CMMI评估是一个十分复杂的过程，更由于其具有的不确定性，在评估的实践中，一定要做到有备无患。真理来自于实践，我们相信，随着越来越多的软件组织着手CMMI评估，越来越多的成功经验将为我们所利用和借鉴。","link":"/2019/05/14/cmmi3/"},{"title":"markdown-apt","text":"概览宗旨Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 兼容 HTMLMarkdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 、、、 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 HTML 的区段（行内）标签如 、、 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 或 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;。 所以你如果要在文档中插入一个版权符号©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 标签。 如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 ，但是简单地「每个换行都转换为 」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You're only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\\. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 和 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ 'Optional Title Here' [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： [id]: &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接 [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 _ 包围的字词会被转成用 标签包围，用两个 * 或 _ 包起来的话，则会被转成 ，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*this text is surrounded by literal asterisks\\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don't use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don't use any &lt;code&gt;&lt;blink&gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 其它反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠： \\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;mailto:addre ss@example.co m&quot;&gt;address@exa mple.com&lt;/a&gt; 在浏览器里面，这段字串（其实是 address@example.com）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 感谢感谢http://daringfireball.net/projects/markdown/ Markdown 免费编辑器Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用(Sublime Text 2 + MarkdownEditing 教程) Sublime Text 2 MarkdownEditing 教程","link":"/2019/05/16/markdown/"},{"title":"linux常用命令","text":"linux常用命令 linux 常用命令1、ls命令 就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等 常用参数搭配： ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 2、cd命令 (changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName 实例： （1）进入要目录 cd / （2）进入&quot;家&quot;目录 cd ~ （3）进入上一次工作路径 cd - （4）把上个命令的参数作为cd参数使用。 cd !$ 3、pwd命令 查看当前工作目录路径 实例： （1）查看当前路径 pwd （2）查看软链接的实际路径 pwd -P 4、mkdir命令 创建文件夹 可用选项： -m: 对新建目录设置存取权限,也可以用chmod命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那 些尚不在的目录,即一次可以建立多个目录; 实例： （1）当前工作目录下创建名为t的文件夹 mkdir t （2）在tmp目录下创建路径为test/t1/t的目录，若不存在，则创建 mkdir -p /tmp/test/t1/t 5、rm命令 删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状 rm [选项] 文件… 实例： （1）删除任何.log文件；删除前逐一询问确认 rm -i *.log （2）删除test子目录及子目录中所有档案删除,并且不用一一确认 rm -rf test （3）删除以-f开头的文件 rm -- -f* 6、rmdir命令 从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。 注意：不能删除非空目录 实例： （1）当parent子目录被删除后使它也成为空目录的话，则顺便一并删除 rmdir -p parent/child/child11 7、mv命令 移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。 当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中 实例： （1）将文件test.log重命名为test1.txt mv test.log test1.txt （2）将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中 mv llog1.txt log2.txt log3.txt /test3 （3）将文件file1改名为file2，如果file2已经存在，则询问是否覆盖 mv -i log1.txt log2.txt （4）移动当前文件夹下的所有文件到上一级目录 mv * ../ 8、cp命令 将源文件复制至目标文件，或将多个源文件复制至目标目录。 注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！ -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 实例： （1）复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖 cp -ai a.txt test （2）为a.txt建议一个链接（快捷方式） cp -s a.txt link_a.txt 9、cat命令 cat主要有三大功能： 1.一次显示整个文件:cat filename 2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件:cat file1 file2 &gt; file -b对非空输出行号 -n输出所有行号 实例： （1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -n log2012.log log2013.log （2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 cat -b log2012.log log2013.log log.log （3）使用here doc生成新文件 cat &gt;log.txt &lt;&lt;EOF HelloWorldPWD=$(pwd)EOF ls -l log.txt cat log.txt Hello World PWD=/opt/soft/test （4）反向列示 tac log.txt PWD=/opt/soft/test World Hello 10、more命令 功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示 -&gt;&gt;命令参数： +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 -&gt;&gt;常用操作命令： Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 实例： （1）显示文件中从第3行起的内容 more +3 text.txt （2）在所列出文件目录详细信息，借助管道使每次显示5行 ls -l | more -5 按空格显示下5行 11、less命令 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数 -i 忽略搜索时的大小写 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例： （1）ps查看进程信息并通过less分页显示 ps -aux | less -N （2）查看多个文件 less 1.log 2.log 可以使用n查看下一个，使用p查看前一个 12、head命令 head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 常用参数： -n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数） 实例： （1）显示1.log文件中前20行 head 1.log -n 20 （2）显示1.log文件前20字节 head -c 20 log2014.log （3）显示t.log最后10行 head -n -10 t.log 13、tail命令 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数： -f 循环读取（常用于查看递增的日志文件） -n&lt;行数&gt; 显示行数（从后向前） （1）循环读取逐渐增加的文件内容 ping 127.0.0.1 &gt; ping.log &amp;（后台运行：可使用jobs -l查看，也可使用fg将其移到前台运行） tail -f ping.log（查看日志） 14、which命令 在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which是在PATH就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 常用参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 实例： （1）查看ls命令是否存在，执行哪个 which ls （2）查看which which which （3）查看cd which cd（显示不存在，因为cd是内建命令，而which查找显示是PATH中的命令） 查看当前PATH配置：echo $PATH；或使用env查看所有环境变量及对应值 15、whereis命令 whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis及locate都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。 常用参数： -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 实例： （1）查找locate程序相关文件 whereis locate （2）查找locate的源码文件 whereis -s locate （3）查找lcoate的帮助文件 whereis -m locate 16、locate命令 locate通过搜寻系统内建文档数据库达到快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性调用的。默认情况下locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)。 locate与find命令相似，可以使用如*、?等进行正则匹配查找 常用参数： -l num（要显示的行数） -f 将特定的档案系统排除在外，如将proc排除在外 -r 使用正则运算式做为寻找条件 实例： （1）查找和pwd相关的所有文件(文件名中包含pwd） locate pwd （2）搜索etc目录下所有以sh开头的文件 locate /etc/sh （3）查找/var目录下，以reason结尾的文件 locate -r '^/var.reason$'（其中.表示一个字符，表示任务多个；.*表示任意多个字符） 17、find命令 用于在文件树中查找文件，并作出相应的处理 命令格式： find pathname -options [-print -exec -ok ...] 命令参数： pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \\;，注意{ }和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项： -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 实例： （1）查找48小时内修改过的文件 find -atime -2 （2）在当前目录查找 以.log结尾的文件。 &quot;. &quot;代表当前目录 find ./ -name '*.log' （3）查找/opt目录下 权限为 777的文件 find /opt -perm 777 （4）查找大于1K的文件 find -size +1000c find -size 1000c 查找等于1000字符的文件 -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。 实例： （5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒） find . -type f -mtime +10 -exec rm -f {} \\; （6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除 find . -name '*.log' mtime +5 -ok -exec rm {} \\; （7）当前目录下查找文件名以passwd开头，内容包含&quot;pkg&quot;字符的文件 find . -f -name 'passwd*' -exec grep &quot;pkg&quot; {} \\; （8）用exec选项执行cp命令 find . -name '*.log' -exec cp {} test3 \\; -xargs find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。 实例： （9）查找当前目录下每个普通文件，然后使用xargs来判断文件类型 find . -type f -print | xargs file （10）查找当前目录下所有以js结尾的并且其中包含'editor'字符的普通文件 find . -type f -name &quot;*.js&quot; -exec grep -lF 'ueditor' {} \\; find -type f -name '*.js' | xargs grep -lF 'editor' （11）利用xargs执行mv命令 find . -name &quot;*.log&quot; | xargs -i mv {} test4 （12）用grep命令在当前目录下的所有普通文件中搜索hostnames这个词,并标出所在行 find . -name *(转义） -type f -print | xargs grep -n 'hostnames' （13）查找当前目录中以一个小写字母开头，最后是4到9加上.log结束的文件 find . -name '[a-z]*[4-9].log' -print （14）在test目录查找不在test4子目录查找 find test -path 'test/test4' -prune -o -print （15）实例1：查找更改时间比文件log2012.log新但比文件log2017.log旧的文件 find -newer log2012.log ! -newer log2017.log 使用depth选项： depth选项可以使find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 实例：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。 它将首先匹配所有的文件然后再进入子目录中查找 find / -name &quot;CON.FILE&quot; -depth -print 18、chmod命令 用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用ls -l test.txt查找 以文件log2012.log为例： -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。 常用参数： -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围： u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文件的当前用户或群组之外的用户或者群组 a ：所有的用户及群组 权限代号： r ：读权限，用数字4表示 w ：写权限，用数字2表示 x ：执行权限，用数字1表示 - ：删除权限，用数字0表示 s ：特殊权限 实例： （1）增加文件t.log所有用户可执行权限 chmod a+x t.log （2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息 chmod u=r t.log -c （3）给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c) （4）将test目录及其子目录所有文件添加可读权限 chmod u+r,g+r,o+r -R text/ -c 19、tar命令 用来压缩和解压文件。tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。 弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件 常用参数： -c 建立新的压缩文件 -f 指定压缩文件 -r 添加文件到已经压缩文件包中 -u 添加改了和现有的文件到压缩包中 -x 从压缩包中抽取文件 -t 显示压缩文件中的内容 -z 支持gzip压缩 -j 支持bzip2压缩 -Z 支持compress解压文件 -v 显示操作过程 有关gzip及bzip2压缩 gzip实例：压缩gzip fileName .tar.gz和.tgz 解压：gunzip filename.gz或gzip -d filename.gz 对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz bz2实例：压缩bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2 对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2 实例： （1）将文件全部打包成tar包 tar -cvf log.tar 1.log,2.log 或tar -cvf log.* （2）将/etc下的所有文件及目录打包到指定目录，并使用gz压缩 tar -zcvf /tmp/etc.tar.gz /etc （3）查看刚打包的文件内容（一定加z，因为是使用gzip压缩的） tar -ztvf /tmp/etc.tar.gz （4）要压缩打包/home, /etc ，但不要 /home/dmtsai tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc 20、chown命令 chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符 -c 显示更改的部分的信息 -R 处理指定目录及子目录 实例： （1）改变拥有者和群组 并显示改变信息 chown -c mail:mail log2012.log （2）改变文件群组 chown -c :mail t.log （3）改变文件夹及子文件目录属主及属组为mail chown -cR mail: test/ （4）改变文件 21、df命令 显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示 -a 全部文件系统列表 -h 以方便阅读的方式显示信息 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地磁盘 -T 列出文件系统类型 实例： （1）显示磁盘使用情况 df -l （2）以易读方式列出所有文件系统及其类型 df -haT 22、du命令 du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看 命令格式： du [选项] [文件] 常用参数： -a 显示目录中所有文件大小 -k 以KB为单位显示文件大小 -m 以MB为单位显示文件大小 -g 以GB为单位显示文件大小 -h 以易读方式显示文件大小 -s 仅显示总计 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 实例： （1）以易读方式显示文件夹内及子文件夹大小 du -h scf/ （2）以易读方式显示文件夹内所有文件大小 du -ah scf/ （3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 du -hc test/ scf/ （4）输出当前目录下各个子目录所使用的空间 du -hc --max-depth=1 scf/ 23、ln命令 功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过ln创建的链接（link）减少磁盘占用量。 链接分类：软件链接及硬链接 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接: 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 需要注意： 第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 常用参数： -b 删除，覆盖以前建立的链接 -s 软链接（符号链接） -v 显示详细处理过程 实例： （1）给文件创建软链接，并显示操作信息 ln -sv source.log link.log （2）给文件创建硬链接，并显示操作信息 ln -v source.log link1.log （3）给目录创建软链接 ln -sv /opt/soft/test/test3 /opt/soft/test/test5 24、date命令 显示或设定系统的日期与时间 命令参数： -d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 显示GMT。 %H 小时(00-23) %I 小时(00-12) %M 分钟(以00-59来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示) %a 星期的缩写。 %A 星期的完整名称。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %m 月份(以01-12来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 实例： （1）显示下一天 date +%Y%m%d --date=&quot;+1 day&quot; //显示下一天的日期 （2）-d参数使用 date -d &quot;nov 22&quot; 今年的 11 月 22 日是星期三 date -d '2 weeks' 2周后的日期 date -d 'next monday' (下周一的日期) date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d date -d last-month +%Y%m(上个月是几月) date -d next-month +%Y%m(下个月是几月) 25、cal命令 可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份 常用参数： -3 显示前一月，当前月，后一月三个月的日历 -m 显示星期一为第一列 -j 显示在当前年第几天 -y [year]显示当前年[year]份的日历 实例： （1）显示指定年月日期 cal 9 2012 （2）显示2013年每个月日历 cal -y 2013 （3）将星期一做为第一列,显示前中后三月 cal -3m 26、grep命令 强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 命令格式： grep [option] pattern file|dir 常用参数： -A n --after-context显示匹配字符后n行 -B n --before-context显示匹配字符前n行 -C n --context 显示匹配字符前后n行 -c --count 计算符合样式的列数 -i 忽略大小写 -l 只列出文件内容符合指定的样式的文件名称 -f 从文件中读取关键词 -n 显示匹配内容的所在文件中行数 -R 递归查找文件夹 grep的规则表达式: ^ #锚定行的开始 如：'^grep'匹配所有以grep开头的行。 #锚定行的结束 如：'grep'匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。 .* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：'A-FH-Zrep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 (..) #标记匹配字符，如'(love)'，love被标记为1。 &lt; #锚定单词的开始，如:'&lt;grep'匹配包含以grep开头的单词的行。 &gt; #锚定单词的结束，如'grep&gt;'匹配包含以grep结尾的单词的行。 x{m} #重复字符x，m次，如：'0{5}'匹配包含5个o的行。 x{m,} #重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。 x{m,n} #重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: '\\bgrep\\b'只匹配grep。 实例： （1）查找指定进程 ps -ef | grep svn （2）查找指定进程个数 ps -ef | grep svn -c （3）从文件中读取关键词 cat test1.txt | grep -f key.log （4）从文件夹中递归查找以grep开头的行，并只列出文件 grep -lR '^grep' /tmp （5）查找非x开关的行内容 grep '^x' test.txt （6）显示包含ed或者at字符的内容行 grep -E 'ed|at' test.txt 27、wc命令 wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出 命令格式： wc [option] file.. 命令参数： -c 统计字节数 -l 统计行数 -m 统计字符数 -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串 实例： （1）查找文件的 行数 单词数 字节数 文件名 wc text.txt 结果：7 8 70 test.txt （2）统计输出结果的行数 cat test.txt | wc -l 28、ps命令 ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top linux上进程有5种状态: \\1. 运行(正在运行或在运行队列中等待) \\2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) \\3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) \\4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) \\5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 命令参数： -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 实例： （1）显示当前所有进程环境变量及进程间关系 ps -ef （2）显示当前所有进程 ps -A （3）与grep联用查找某进程 ps -aux | grep apache （4）找出与 cron 与 syslog 这两个服务有关的 PID 号码 ps aux | grep '(cron|syslog)' 29、top命令 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 常用参数： -c 显示完整的进程命令 -s 保密模式 -p &lt;进程号&gt; 指定进程显示 -n &lt;次数&gt;循环显示次数 实例： （1） top - 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35 Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java 前五行是当前系统情况整体的统计信息区， 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下： 14:06:23 — 当前系统时间 up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！） 2 users — 当前有2个用户登录系统 load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。 load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 第二行，Tasks — 任务（进程），具体信息说明如下： 系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。 第三行，cpu状态信息，具体属性说明如下： 5.9%us — 用户空间占用CPU的百分比。 3.4% sy — 内核空间占用CPU的百分比。 0.0% ni — 改变过优先级的进程占用CPU的百分比 90.4% id — 空闲CPU百分比 0.0% wa — IO等待占用CPU的百分比 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比 0.2% si — 软中断（Software Interrupts）占用CPU的百分比 备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！ 第四行,内存状态，具体信息如下： 32949016k total — 物理内存总量（32GB） 14411180k used — 使用中的内存总量（14GB） 18537836k free — 空闲内存总量（18GB） 169884k buffers — 缓存的内存量 （169M） 第五行，swap交换分区信息，具体信息说明如下： 32764556k total — 交换区总量（32GB） 0k used — 使用的交换区总量（0K） 32764556k free — 空闲交换区总量（32GB） 3612636k cached — 缓冲的交换区总量（3.6GB） 第六行，空行。 第七行以下：各进程（任务）的状态监控，项目列信息说明如下： PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） top交互命令 h 显示top交互命令帮助信息 c 切换显示命令名称和完整命令行 m 以内存使用率排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 o或者O 改变显示项目的顺序 30、kill命令 发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 常用参数： -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 实例： （1）先使用ps查找进程pro1，然后用kill杀掉 kill -9 $(ps -ef | grep pro1) 31、free命令 显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 命令参数： -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s&lt;间隔秒数&gt; 持续显示内存 -t 显示内存使用总合 实例： （1）显示内存使用情况 free free -k free -m （2）以总和的形式显示内存的使用信息 free -t （3）周期性查询内存使用情况 free -s 10","link":"/2019/04/22/linux常用命令/"}],"tags":[{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"restify","slug":"restify","link":"/tags/restify/"},{"name":"cmmi","slug":"cmmi","link":"/tags/cmmi/"},{"name":"huawei-iot","slug":"huawei-iot","link":"/tags/huawei-iot/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"apt","slug":"apt","link":"/tags/apt/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"}],"categories":[{"name":"技术文章","slug":"技术文章","link":"/categories/技术文章/"},{"name":"认证","slug":"认证","link":"/categories/认证/"}]}
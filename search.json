                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   [{"title":"npm 使用国内源","url":"/2019/04/30/npm-to-ali-source/","content":"切换npm使用的源地址Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源。不安装 cnpm 只用淘宝镜像，设置 npm 的镜像：$ npm config set registry https://registry.npm.taobao.org/执行下面的命令，确认是否切换成功。$ npm config get registry","tags":["nodejs"]},{"title":"app-reset-design","url":"/2019/04/25/android-build/","content":"示例Android Build类Android Build类Build类提供了硬件厂商、编号、序列号、SDK版本等重要信息。类名：android.os.Build常量名说明BOARD底层板名称BOOTLOADERBootloader版本号BRAND品牌CPU_ABICPU指令集CPU_ABI2CPU第二指令集DEVICE工业设计名称DISPLAY显示给用户的构建ID字符串FINGERPRINT构建的唯一标识符HARDWARE硬件的名称 比如高通HOST主机IDID标签MANUFACTURER产品生产商MODEL手机型号PRODUCT产品名称RADIO无线电固件版本号SERIAL硬件序列号（如果可用）TAGS逗号分隔标签描述构建，如”调试”TIME出场时间TYPE构建类型USER构建用户名称2.Build.VERSION类Build.VERSION类提供了开发代号、内部版本、SDK版本等信息类名：android.os.Build.VEISION常量名说明CODENAME当前的开发代号INCREMENTAL使用的内部值表示这个构建底层的源代码控制RELEASE用户可见版本字符串SDK_INT用户可见的SDK版本的框架3.Build.VERSION_CODES类android.os.Build.VERSION_CODES枚举当前已知的SDK版本代号常量名说明BASE2008-10：第一个版本的androidBASE_1_12009-02：第一个安卓更新，官方称为1.1CUPCAKE2009-05：android1.5CUR_DEVELOPMENT发展过程中构建的版本，但是未正式发布DONUT2009-09：android1.6ECLAIR2009-11：android2.0ECLAIR_0_12009-12：android2.0.1ECLAIR_MR12010-01：android2.1FROYO2010-06：android2.2GINGERBREAD2010-11：android2.3GINGERBREAD_MR12011-02：android2.3.3HONEYCOMB2011-02：android3.0HONEYCOMB_MR12011-05：android3.1HONEYCOMB_MR22011-06：android3.2ICE_CREAM_SANDWICH2011-10：android4.0ICE_CREAM_SANDWICH_MR12011-12android4.0.3JELLY_BEAN2012-06：android4.1JELLY_BEAN_MR1android4.2JELLY_BEAN_MR2android4.3KITKATandroid4.4","tags":["Android","version"],"categories":["技术文章"]},{"title":"app-reset-design","url":"/2019/04/25/app-rest-desig/","content":"定义apiResultFull api根据resetfull API 规范定义一个自己的 api规范定义格式如下/app/userid/resnameGET    查询POST   新增PUT    修改DELETE 删除所有请求使用http中请求类型表示其目的url只定义资源的路径包含一下几个动作类型资源服务器提供登录验证资源服务器提供版本支持和不同格式的请求第一个版本只提供json的格式请求","tags":["node","restify"],"categories":["技术文章"]},{"title":"node-restify","url":"/2019/04/25/node-restify/","content":"A Node.js web service framework optimized for building semantically correct RESTful web services ready for production use at scale. restify optimizes for introspection and performance, and is used in some of the largest Node.js deployments on Earth.","tags":["node","restify"],"categories":["技术文章"]},{"title":"http-method-definitions","url":"/2019/04/25/http-method-definitions/","content":"介绍http中method的定义9 Method DefinitionsThe set of common methods for HTTP/1.1 is defined below. Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers.The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests.9.1 Safe and Idempotent Methods9.1.1 Safe MethodsImplementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others.In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered “safe”. This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.9.1.2 Idempotent MethodsMethods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.However, it is possible that a sequence of several requests is non- idempotent, even if all of the methods executed in that sequence are idempotent. (A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence.A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources).9.2 OPTIONSThe OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.Responses to this method are not cacheable.If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field. Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. A server that does not support such an extension MAY discard the request body.If the Request-URI is an asterisk (““), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. Since a server’s communication options typically depend on the resource, the ““ request is only useful as a “ping” or “no-op” type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification. The response body, if any, SHOULD also include information about the communication options. The format for such abody is not defined by this specification, but might be defined by future extensions to HTTP. Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of “0”.The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. If the Max-Forwards field-value is zero (“0”), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options. If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.9.3 GETThe GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process.The semantics of the GET method change to a “conditional GET” if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.The semantics of the GET method change to a “partial GET” if the request message includes a Range header field. A partial GET requests that only part of the entity be transferred, as described in section 14.35. The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13.See section 15.1.3 for security considerations when used for forms.9.4 HEADThe HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.9.5 POSTThe POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. POST is designed to allow a uniform method to cover the following functions:The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.POST requests MUST obey the message transmission requirements set out in section 8.2.See section 15.1.3 for security considerations.9.6 PUTThe PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request – the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.A single resource MAY be identified by many different URIs. For example, an article might have a URI for identifying “the current version” which is separate from the URI identifying each particular version. In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.HTTP/1.1 does not define how a PUT method affects the state of an origin server.PUT requests MUST obey the message transmission requirements set out in section 8.2.Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.9.7 DELETEThe DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity.If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.9.8 TRACEThe TRACE method is used to invoke a remote, application-layer loop- back of the request message. The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. The final recipient is either theorigin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). A TRACE request MUST NOT include an entity.TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of “message/http”. Responses to this method MUST NOT be cached.9.9 CONNECTThis specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling [44]).","tags":["node","restify"],"categories":["技术文章"]},{"title":"Hello","url":"/2019/04/22/hexo/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new postMore info: WritingRun serverMore info: ServerGenerate static filesMore info: GeneratingDeploy to remote sitesMore info: Deployment","tags":["hexo"],"categories":["技术文章"]},{"title":"user-linux","url":"/2019/04/22/linux-user/","content":"linux 下用户管理如何添加或删除ubuntu用户和组在创建用户时，需要为新建用户指定一用户组，如果不指定其用户所属的工作组，自动会生成一个与用户名同名的工作组。创建用户user1的时候指定其所属工作组users，例：useradd –g users user1一、创建用户：使用命令 useradd例：useradd user1——创建用户user1例：useradd –u 600 user3  使用 passwd 命令为新建用户设置密码例：passwd user1注意：没有设置密码的用户不能使用。命令 usermod 修改用户账户例：将用户 user1的登录名改为  u1，usermod –l u1 user1例：将用户 user1 加入到 users组中，usermod –g users user1例：将用户 user1 目录改为/users/us1使用命令 userdel 删除用户账户例：删除用户user2userdel user2例：删除用户 user3，同时删除他的工作目录userdel –r user3查看用户信息id命令查看一个用户的UID和GID, 例：查看user4的idid user4finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息例：finger user4二、用户组：命令 groupadd创建用户组groupadd –g 888 users创建一个组users，其GID为888命令 gpasswd为组添加用户只有root和组管理员能够改变组的成员：例：把 user1加入users组gpasswd –a user1 users例：把 user1退出users组gpasswd –d user1 users命令groupmod修改组groupmod –n user users       修改组名user为usersgroupdel删除组groupdel users    删除组users","tags":["linux","shell"],"categories":["技术文章"]},{"title":"crontab-定时使用","url":"/2019/04/22/linux-crontab/","content":"linux 定时器的使用crontab 定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。1. 命令格式crontab [-u user] file crontab [-u user] [ -e | -l | -r ]2. 命令参数-u user：用来设定某个用户的crontab服务；file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。3. crontab的文件格式分 时 日 月 星期 要运行的命令第1列分钟0～59第2列小时0～23（0表示子夜）第3列日1～31第4列月1～12第5列星期0～7（0和7表示星期天）第6列要运行的命令4. 常用方法创建一个新的crontab文件向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$HOME目录下的. profile文件，在其中加入这样一行:然后保存并退出。不妨创建一个名为 cron的文件，其中是用户名，例如， davecron。在该文件中加入如下的内容。保存并退出。注意前面5个域用空格分隔。在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数:现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。列出crontab文件使用-l参数列出crontab文件:可以使用这种方法在$HOME目录中对crontab文件做一备份:这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。编辑crontab文件如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件:可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：保存并退出。注解最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。删除crontab文件5. 使用实例实例1：每1分钟执行一次myCommand实例2：每小时的第3和第15分钟执行实例3：在上午8点到11点的第3和第15分钟执行实例4：每隔两天的上午8点到11点的第3和第15分钟执行实例5：每周一上午8点到11点的第3和第15分钟执行实例6：每晚的21:30重启smb实例7：每月1、10、22日的4 : 45重启smb实例8：每周六、周日的1 : 10重启smb实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb实例10：每星期六的晚上11 : 00 pm重启smb实例11：每一小时重启smb实例12：晚上11点到早上7点之间，每隔一小时重启smb6. 使用注意事项注意环境变量问题有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：脚本中涉及文件路径时写全局路径；脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:注意清理系统用户的邮件日志每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出:“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。系统级任务调度与用户级任务调度系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。其他注意事项新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。当crontab失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:ubuntu下启动、停止与重启cron:","tags":["linux","shell"],"categories":["技术文章"]},{"title":"linux常用命令","url":"/2019/04/22/linux常用命令/","content":"linux常用命令linux 常用命令1、ls命令   就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等    常用参数搭配：    ls -a 列出目录所有文件，包含以.开始的隐藏文件    ls -A 列出除.及..的其它文件       2、cd命令3、pwd命令4、mkdir命令5、rm命令6、rmdir命令       从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。         注意：不能删除非空目录         实例：         （1）当parent子目录被删除后使它也成为空目录的话，则顺便一并删除         rmdir -p parent/child/child117、mv命令8、cp命令9、cat命令HelloWorldPWD=$(pwd)EOF         ls -l log.txt         cat log.txt         Hello         World         PWD=/opt/soft/test         （4）反向列示         tac log.txt         PWD=/opt/soft/test         World         Hello10、more命令11、less命令   less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。         常用命令参数         -i  忽略搜索时的大小写         -N  显示每行的行号         -o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来         -s  显示连续空行为一行         /字符串：向下搜索“字符串”的功能         ?字符串：向上搜索“字符串”的功能         n：重复前一个搜索（与 / 或 ? 有关）         N：反向重复前一个搜索（与 / 或 ? 有关）         -x &lt;数字&gt; 将“tab”键显示为规定的数字空格         b  向后翻一页         d  向后翻半页         h  显示帮助界面         Q  退出less 命令         u  向前滚动半页         y  向前滚动一行         空格键 滚动一行         回车键 滚动一页         [pagedown]： 向下翻动一页         [pageup]：   向上翻动一页         实例：         （1）ps查看进程信息并通过less分页显示         ps -aux | less -N         （2）查看多个文件         less 1.log 2.log         可以使用n查看下一个，使用p查看前一个12、head命令13、tail命令14、which命令15、whereis命令16、locate命令17、find命令18、chmod命令19、tar命令20、chown命令　　　　chown -c mail:mail log2012.log         （2）改变文件群组         chown -c :mail t.log         （3）改变文件夹及子文件目录属主及属组为mail         chown -cR mail: test/         （4）改变文件21、df命令22、du命令23、ln命令24、date命令25、cal命令26、grep命令27、wc命令28、ps命令29、top命令30、kill命令31、free命令","tags":["linux","shell"],"categories":["技术文章"]}]